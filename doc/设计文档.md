## 1. 简介
该网站主要目的为在公司内部展示软件算法组的特定算法，例如特定靶标抓取，图像测量，字符识别等算法。

## 2. 功能需求
访问用户可以自主选择算法并且输入特定参数进行演示，在界面可以选择自定义图片上传，并且在上传的图片右边生成经过算法处理后的图片，以展示对比的效果。


## 3. 技术选择
### 可行方案
根据项目需求和技术要求，我评估了以下几种前端框架方案：

### 1. .NET Core Razor Pages
.NET Core Razor Pages 是一个基于 .NET Core 平台的 Web 应用程序框架，它使用 Razor 模板引擎和页面模型来实现快速、简单的 Web 页面开发。Razor Pages 提供了与 ASP.NET MVC 相似的开发模式，但更加轻量级和简洁。它适用于快速构建简单、交互性较低的页面，并且与后端的 C# 代码无缝集成。 Razor Page 方法按功能对与特定页面相关的所有内容进行分组，意味着无论何时在处理特定页面时，都可以在控制器、视图和视图模型文件夹之间上下滚动

### 2. ASP.NET MVC
ASP.NET MVC 是一个成熟的 Web 应用程序框架，它基于模型-视图-控制器（MVC）模式，提供了良好的分离关注点、可扩展性和灵活性。它适合构建复杂的 Web 应用程序，并且与 C# 后端代码紧密集成。与Razor Pages不同的是，MVC 按类型（控制器、视图、视图模型）对类进行分组，并且一个控制器可以有多个动作方法，可能会导致控制器变得非常庞大和臃肿，具有许多依赖关系。

### 3. Blazor
Blazor 是一个使用 C# 构建现代、交互式 Web 用户界面的开源框架。它通过在浏览器中运行 .NET 代码，实现了将 C# 代码直接用于前端开发的能力。Blazor 可以选择使用 WebAssembly 或者基于 SignalR 的服务器端模式来运行。它适用于需要高度交互性和实时更新的应用程序。

### 选择理由
基于我们项目的需求和技术要求，我选择了.NET Core Razor Pages 作为我们的前端框架，原因有以下：

- .NET Core 生态系统：我们的图片处理算法主要基于 C# 和 C++ 代码，而 .NET Core 提供了良好的支持和集成。使用 Razor Pages 可以方便地与后端的 C# 代码进行交互，并充分利用 .NET Core 的功能和库。
- 快速开发：Razor Pages 提供了简单且直观的开发模式，使得开发人员可以快速构建页面并实现所需的功能。它的模型绑定和路由系统能够简化开发流程，减少样板代码的编写。
- 轻量级和简洁：相比于 ASP.NET MVC，Razor Pages 更加轻量级和简洁。对于内部展示图片处理算法的需求，我们应更注重快速开发和易于维护，因此选择 Razor Pages 可以帮助我们更快地推出功能，并降低维护成本。
- 自带 Bootstrap5 框架：Bootstrap 5 提供了强大的响应式设计支持，能够根据不同设备的屏幕尺寸和分辨率自动调整页面布局和样式。此外还提供了丰富的预定义组件，如导航栏、按钮、表单、卡片等，可以快速构建出具有一致外观和交互效果的界面。这些功能易于使用和定制，能够提高开发效率，减少样式编写的工作量。

## 4. 文件结构
 ``` 
├── 3rd
├── Pages
│   ├── _ViewImports.cshtml
│   ├── _ViewStart.cshtml
│   ├── Privacy.cshtml
│   ├── Privacy.cshtml.cs
│   ├── Algorithm
│       ├── Index.cshtml
│       └── Index.cshtml.cs
│   └── Shared
│       ├── _Layout.cshtml
│       └── _ValidationScriptsPartial.cshtml
├── appsettings.json
├── appsettings.Development.json
├── Program.cs
├── AlgoDisplay.csproj
└── wwwroot
    ├── css
    ├── models
    ├── js
    ├── icons
    └── images

 ```

-  以下是对各个文件和文件夹的简要说明：

    3rd：包含算法所需依赖库和模型的文件夹。
    - 编译后会通过Post-build event命令将文件转移到目标目录：
    ```
    xcopy /S /Y "$(ProjectDir)3rd\opencv_world455d.dll" "$(TargetDir)"
    xcopy /S /Y "$(ProjectDir)3rd\yoloV7-test1.dll" "$(TargetDir)"
    ```

	Pages: 包含Razor Pages的文件夹，每个Razor Page都对应一个.cshtml和一个.cshtml.cs文件。

	_ViewImports.cshtml: 在所有Razor Pages中导入命名空间和引用。

	_ViewStart.cshtml: 设置Razor Pages的默认布局文件。

	Privacy.cshtml: 隐私政策页面的Razor Page视图。

	Privacy.cshtml.cs: 隐私政策页面的Razor Page代码后端。

	Algorithm: 存放算法展示页面的文件夹。

	Index.cshtml: 网站首页的Razor Page视图。

	Index.cshtml.cs: 网站首页的Razor Page代码后端。

	Shared: 存放多个Razor Pages共享的部分视图和代码文件夹。

	_Layout.cshtml: 网站的布局视图，包含通用的HTML结构和导航栏。

	_ValidationScriptsPartial.cshtml: 包含客户端验证脚本的部分视图。

	appsettings.json: 应用程序的配置文件，存储应用程序的设置和连接字符串等。

	appsettings.Development.json: 开发环境下的配置文件，通常用于存储开发时的特定设置。

	Program.cs: 应用程序的入口点，用于配置和启动应用程序。

	AlgoDisplay.csproj: 项目文件，用于定义项目的依赖项和构建设置。

	wwwroot: 存放静态资源（如CSS、JavaScript和图像文件）的项目根目录。

	css: 存放CSS样式文件的文件夹。

    models：存放算法模型的文件夹。

	js: 存放JavaScript文件的文件夹。

	images: 存放上传图像和生成图像的文件夹。

	icons: 存放加载网站所需图片的文件夹。


## 5. 页面结构

### 算法展示页面 (Index.cshtml)

#### 第一部分：图片展示
- 页面目的：展示算法选择和图片上传功能，以及显示算法参数和算法简介的卡片。
- 页面布局和设计：使用Bootstrap样式和栅格布局，主要分为三行。

![](https://git.local/algorithm_show/algo_show/-/raw/main/doc/mdPhotos/%E7%BB%93%E6%9E%84.jpg)
  1. 第一行：算法选择和图片上传表单，并包含运行和重置按钮。
  		- 交互方式：
		    1. 选择算法：通过下拉菜单选择要运行的算法。
		    2. 上传图片：通过文件选择框选择要处理的图片。
		    3. 运行按钮：点击按钮触发算法运行操作。
		    4. 重置按钮：点击按钮重置表单和结果。



2. 第二行：输入参数和算法简介
		
	- 目的：展示当前选择算法的参数，并允许用户输入参数值。
		
	- 布局和设计：使用Bootstrap卡片组件，显示算法参数的名称和输入字段，以及算法的简介文本。
		
	- 交互方式：显示当前算法所需的参数名称，用户可以输入参数值，并且展示相应算法的简介。

3. 第三行：原图和处理后图片
		
	- 目的： 展示用户上传的原始图片以及算法处理后的图片结果。
		
	- 布局和设计：使用Bootstrap卡片组件，包含一个显示原图的图片框和一个显示算法处理后的图片框。

#### 第二部分：算法介绍
![](https://git.local/algorithm_show/algo_show/-/raw/main/doc/mdPhotos/%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D.jpg)
- 页面目的：展示对算法的详细介绍。
- 页面布局和设计：使用Bootstrap样式和栅格布局，包含一个标题和算法介绍的文本内容。
- 交互方式：
	1. 标题：对应算法的名称。
	2. 文本内容：展示对算法的详细介绍的文本。

### 隐私页面 (Privacy.cshtml)
![](https://git.local/algorithm_show/algo_show/-/raw/main/doc/mdPhotos/%E9%9A%90%E7%A7%81.png)
- 页面目的：展示隐私政策条例。


## 6. 功能实现
本项目代码主要由视图部分和算法部分组成，前者主要由Html，Javascript以及Bootstrap实现网页布局和功能，后者由C#实现图片处理算法。
### 视图部分
- 指定视图的模型，并引入必要的命名空间。
```html
@page
@model AlgoDisplay.Pages.Algorithm.IndexModel
@{
}
``` 
- 回到页面顶部按钮。
```html
<button onclick="topFunction()" id="myBtn" title="回到顶部" class="bg-primary btn-sm fs-3"> &Hat; </button>
``` 
对应js代码为
```js
// 获取按钮
let mybutton = document.getElementById("myBtn");

// 向下滚动页面就显示按钮
window.onscroll = function () { scrollFunction() };

function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
        mybutton.style.display = "block";
    } else {
        mybutton.style.display = "none";
    }
}

// 点击按钮回到top
function topFunction() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
}
```
- 第10行到第31行：创建了一个表单，用于选择算法和上传图片,并包含运行和重置按钮。
```html
    <form method="post" enctype="multipart/form-data" class="bg-light">
        <div class=" justify-content-sm-between">
            <div for="algorithm" class="form-control text-black col-md-2 col-12 text-center">
                选择算法：
                <select name="algorithm" id="algorithm">
                    <option value="default">请选择算法</option>
                    <option value="algorithm1">算法1</option>
                    <option value="algorithm2">算法2</option>
                    <option value="algorithm3">算法3</option>
                    <option value="algorithm4">算法4</option>
                </select>
                <label class="ms-5" for="image">上传图片：</label>
                <input class="col-3 align-self-sm-start" type="file" name="image" id="image" accept="image/jpeg, image/gif, image/png" onchange="showImg(this)">
                <input type="submit" class="btn btn-primary text-white col-lg-2 col-md-4 col-sm-5 col-11 me-md-3 mb-sm-0 mb-1" value="运行" onclick="runAlgorithm()">
                <input type="button" class="btn btn-secondary text-white col-lg-2 col-md-4 col-sm-5 col-11" value="重置" onclick="resetForm()">
            </div>
        </div>
    </form>
```

其中运行按钮包含js的runAlgorithm，效果为当未选择算法和上传图片时点击运行会提示弹窗。
```js
//点击运行按钮提示
function runAlgorithm() {
    var algorithm = document.getElementById("algorithm").value;
    var image = document.getElementById("image").value;
    var parameterContainer = document.getElementById("parameter-container");
    var parameters = parameterContainer.querySelectorAll("input");

    if (algorithm === "default") {
        alert("请选择算法！");
        return false;
    }

    if (image === "") {
        alert("请先上传图片！");
        return false;
    }
}
```
重置按钮功能由js代码实现，目的为重置图片框，算法和参数选择。
```js
//重置按钮
function resetForm() {
    form.reset();
    algorithmDescription.textContent = '请选择一个算法查看相应简介。'
    for (let i = 0; i < originalImageElements.length; i++) {
        originalImageElements[i].src = '';
    }
    originalImageDiv.src = "/icons/grey.jpg";
    processImageDiv.src = "/icons/grey.jpg";
    //重置参数选择
    parameterForm.innerHTML = `
                <div class="card-body bg-light d-flex align-items-center">
                        请选择算法以输入相应参数！
                </div>
     `;
    algorithmSelector.value = 'default';
}
```
- 第34行到第57行：算法参数和算法简介的两个部分。
  - 使用asp-page表单提交到后端目的为未来将参数传入到后端直接在算法中使用。
```html
    <!-- 参数与算法简介 -->
         <div class="mb-3 d-flex">
            <div class="card  bg-light w-100 d-flex">
                <div class="fs-3 fw-bolder card-header text-black text-center">
                    输入参数
                </div>

                 @*asp-page表单提交到后端*@
                 <form class="algorithm-parameter" id="parameter-container" method="post" asp-page="/Algorithm/Index">
                    <div class="card-body bg-light d-flex align-items-center">
                            请选择算法以输入相应参数。
                    </div>
                </form>
            </div>


            <div class="card border-info w-100 d-flex">
                <div class="fs-3 fw-bolder card-header text-black text-center">
                    算法简介
                </div>
			<div class="algorithm-description card-body d-flex align-items-center text-info">
                            请选择一个算法查看相应简介。
                    </div>
            </div>
        </div>
```
- 第60行到第104行：展示了原图和处理后图片的两个卡片，使用了条件判断来确定展示的图片路径。主要逻辑为使用ViewData引用后端代码中的图片路径。
```html
<div class="row mt-3" style="min-height: 50vh;">
        <div class="col-md-6 mb-3 d-flex">
            <div class="card w-100">
                <div class="card-header bg-warning text-white text-center">
                    原图
                </div>
                <div class="card-body bg-light d-flex align-items-center">
                    <div class="original-image">
                        @*由于调用yolo_test会自动刷新页面，所以当输出为空时，输入图片展示灰图；当输出框为处理后的图片时，输入图片为上传图*@
                        @{
                            if (!string.IsNullOrEmpty(ViewData["ProcessedImageUrl"] as string))
                            {
                                ViewData["OriginalImageUrl"] = "/images/original.jpg";
                            }

                            else
                            {
                                ViewData["OriginalImageUrl"] = "/icons/grey.jpg";
                            }
                        }
                            <img id="upload" src="@ViewData["OriginalImageUrl"]" alt="初始图片" class="img-fluid">
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-6 mb-3 d-flex">
            <div class="card w-100">
                <div class="card-header bg-warning text-white text-center">
                    处理后
                </div>
                <div class="card-body bg-light d-flex align-items-center">
                    <div class="processed-image">
                        @*<img id="process" src="~/icon/grey.jpg" alt="处理后的图片" class="img-fluid">*@
                        
                        @if (!string.IsNullOrEmpty(ViewData["ProcessedImageUrl"] as string))
                        {
                            <img id="process" src="@ViewData["ProcessedImageUrl"]" alt="处理后的图片" class="img-fluid">
                        }
                          @*<img id="process" src="~/AlgoDisplay/result.jpg" alt="处理后的图片" class="img-fluid">*@
                    </div>
                </div>
            </div>
        </div>
    </div>
```
- 第108行到第283行：使用Bootstrap的手风琴组件展示了算法介绍的部分，包含算法名称和对应介绍。
```html
  <!-- 算法介绍 -->
  <section id="Introductions" class="bg-light mt-5 py-5">
    <div class="container-md">
      <div class="text-center">
        <h2>算法介绍</h2>
        <p class="lead text-muted">以下是对算法的详细介绍</p>
      </div>
      <div class="row my-3 g-5 justify-content-around align-items-center">
        <div class="col-6 col-lg-4">
             <img src="~/icons/Software.jpg" class="img-fluid" alt="software">
        </div>
        <div class="col-lg-6">

          <!-- accordion -->
          <div class="accordion" id="chapters">
            <div class="accordion-item">
              <h2 class="accordion-header" id="heading-1">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#algo-1" aria-expanded="true" aria-controls="algo-1">
                  Algorithm 1 - 算法名称
                </button>
              </h2>
              <div id="algo-1" class="accordion-collapse collapse show" aria-labelledby="heading-1" data-bs-parent="#chapters">
                <div class="accordion-body">
                  <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Quis assumenda delectus sapiente quidem consequatur odit adipisci necessitatibus nemo aliquid minus modi tempore quibusdam quas vitae, animi ipsam nulla sunt alias.</p>
                  <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Quis assumenda delectus sapiente quidem consequatur odit adipisci necessitatibus nemo aliquid minus modi tempore quibusdam quas vitae, animi ipsam nulla sunt alias.</p>
                </div>
              </div>
            </div>
			@...此处省略
		/div>
      </div>
    </div>
  </section>
```
### 算法部分（后端代码）
- 第26行到第27行：声明了一些外部方法，用于调用C++ DLL中的算法函数。由于C#算法还未集成，所以先使用郑超老师训练的yolotest模型作为演示算法1。
```c#
       [DllImport("yoloV7-test1.dll", EntryPoint = "yoloTest", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
        public static extern int yolo_test(IntPtr sourceImg, ref byte strPath);
```
中间代码多为郑超老师的靶标识别算法相应函数和结构体，尚未走通。

- 第603行到第608行：构造函数，用于注入IWebHostEnvironment依赖。
```c#
        private readonly IWebHostEnvironment _webHostEnvironment;

        public IndexModel(IWebHostEnvironment webHostEnvironment)
        {
            _webHostEnvironment = webHostEnvironment;
        }
```
- 第612行到第833行：OnPostAsync方法，用于处理页面的表单提交，包括选择算法和上传图片，并根据选择的算法对图像进行处理。
```c#
        public async Task<IActionResult> OnPostAsync(string algorithm, IFormFile image)
        {
            // 获取wwwroot目录的完整路径
            var webRootPath = _webHostEnvironment.WebRootPath;
            //Console.WriteLine(webRootPath);

            // 检查是否选择了算法和上传了图片
            if (string.IsNullOrEmpty(algorithm) || image == null || image.Length == 0)
            {
                return Page();
            }

            var originImagePath = "";
            var processedImagePath = "";
            // 将上传的图片保存到wwwroot目录下的images文件夹中
            string imgData = Path.Combine(webRootPath, "images", "original.jpg");
            using var stream = new FileStream(imgData, FileMode.Create);
            await image.CopyToAsync(stream);


            // 根据选择的算法对图像进行处理
            if (algorithm == "algorithm1")
            {
                // 执行ִ算法1
                // ...
                Stopwatch sw = new Stopwatch();
                Bitmap CurPreviewImage = ConvertToBitmap(image);
                GCHandle imgHandle = new GCHandle();
                byte[] s = new byte[256];
                using (GrayBitmap bmp = GrayBitmap.FromBitmap(CurPreviewImage))
                {
                    sw.Start();
                    imgHandle = GCHandle.Alloc(bmp, GCHandleType.Pinned);
                    try
                    {
                        int result = yolo_test(imgHandle.AddrOfPinnedObject(), ref s[0]);
                    }
                    catch(Exception e) {
                        Console.WriteLine(e.Message);
                    }

                    finally
                    {
                        sw.Stop();
                        imgHandle.Free();
                        //在根目录中创建processed.jpg
                        processedImagePath = Path.Combine(webRootPath, "images", "processed.jpg");

                        // 检查是否存在processed.jpg
                        if (System.IO.File.Exists(processedImagePath))
                        {
                            System.IO.File.Delete(processedImagePath);
                        }
                        Console.WriteLine(processedImagePath);
                    }

                }
            }

            else if (algorithm == "algorithm2")
            {
                //// ִ执行算法2

            }

            else if (algorithm == "algorithm3")
            {
                // ִ执行算法3
                // ...
            }

            else if (algorithm == "algorithm4")
            {
                // ִ执行算法4
                // ...
            }

            else
            {
                // 未知算法名称
                return Page();
            }

            originImagePath = "/images/original.jpg";
            processedImagePath = "/images/processed.jpg";
			// 使用ViewData可使前端能直接调用
            ViewData["OriginalImageUrl"] = originImagePath;
            ViewData["ProcessedImageUrl"] = processedImagePath;
            return Page();
		}
	}
```
算法1为郑超老师提供的yolotest，先将上传的图片转为Bitmap，再转换为自定义的GreyBitmap，使用GCHandle.Alloc将其钉在内存中，获取钉在内存中的对象的指针并将其传递给yolo_test函数，生成的图片更名为processed.jpg存放于wwwroot/images里。
## 7. 部署
1.Razor Pages本地IIS服务器部署流程及部分问题解决方法，
[网页版](https://m6faef7keg.feishu.cn/docx/Qc3odS5ytoyEpqxGay1cEl0Cn8c)，
[PDF](Razor Pages本地IIS服务器部署流程及部分问题解决方法.pdf)

2.使用 GitLab CI/CD 实现自动化发布网站至IIS服务器，
[网页版](https://m6faef7keg.feishu.cn/docx/A0hLdA97poHTdPxTgXUcLeDGnfg)，
[PDF](使用 GitLab CI_CD 实现自动化发布网站至IIS服务器.pdf)
